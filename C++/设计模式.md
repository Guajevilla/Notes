# 1. DesignPatterns
## 1.1. 面向对象设计原则
### 1.1.1. 依赖倒置原则(DIP)
    高层模块(稳定)不应该依赖于低层模块(变化),二者都应该依赖于抽象(稳定) 。   
    抽象(稳定)不应该依赖于实现细节(变化) ,实现细节应该依赖于抽象(稳定)。   

![ ](_v_images/20200925152422955_235768325.png)
### 1.1.2. 开放封闭原则(OCP)
    对扩展开放,对更改封闭。
    类模块应该是可扩展的,但是不可修改。 
### 1.1.3. 单一职责原则(SRP)
    一个类应该仅有一个引起它变化的原因。
    变化的方向隐含着类的责任。
### 1.1.4. Liskov 替换原则(LSP)
    子类必须能够替换它们的基类(IS-A)。
    继承表达类型抽象。
### 1.1.5. 接口隔离原则(ISP)
    不应该强迫客户程序依赖它们不用的方法。
    接口应该小而完备。
### 1.1.6. 优先使用对象组合,而不是类继承
    类继承通常为“白箱复用”,对象组合通常为“黑箱复用”。
    继承在某种程度上破坏了封装性,子类父类耦合度高。
    而对象组合则只要求被组合的对象具有良好定义的接口,耦合度低。
### 1.1.7. 封装变化点
    使用封装来创建对象之间的分界层,让设计者可以在分界层的一侧进行修改,而不会对另一侧产生不良的影响,从而实现层次间的松耦合。
### 1.1.8. 针对接口编程,而不是针对实现编程
    不将变量类型声明为某个特定的具体类,而是声明为某个接口。
    客户程序无需获知对象的具体类型,只需要知道对象所具有的接口。
    减少系统中各部分的依赖关系,从而实现“高内聚、松耦合”的类型设计方案。
## 设计模式的一些分类
![](_v_images/20200925160930771_360402816.png)
![](_v_images/20200925160843895_2137119117.png)
设计模式的应用不宜先入为主,一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。
### 重构关键技法
静态 -> 动态
早绑定 -> 晚绑定
继承 -> 组合
编译时依赖 -> 运行时依赖
紧耦合 -> 松耦合
## Template Method 模板方法模式
在软件构建过程中,对于某一项任务,它常常有稳定的整体操作结构,但各个子步骤却有很多改变的需求
```C++
class Library{
public:
    void Run(){
        
        Step1();

        if (Step2()) { 
            Step3(); 
        }

        for (int i = 0; i < 4; i++){
            Step4(); 
        }

        Step5();

    }
	virtual ~Library(){ }

protected:
	void Step1() { 
        //.....
    }
	void Step3() {
        //.....
    }
	void Step5() { 
		//.....
	}

	virtual bool Step2() = 0;
    virtual void Step4() =0; 
};
```
### 模式定义
定义一个操作中的算法的骨架 （稳定，如Run() 等过程），而将一些步骤延迟(变化)到子类中。Template Method 使得子类可以不改变(复用)一个算法的结构，即可重定义（override 重写，利用虚函数）该算法的某些特定步骤。（这个过程也是体现了晚绑定的思想）

在具体实现方面,被Template Method调用的虚方法可以具有实现，也可以没有任何实现(抽象方法、纯虚方法)，但一般推荐将它们设置为**protected**方法（因为这样的虚方法一般都是要被基类中稳定的骨架方法所调用的，而不暴露在类外）。
## Strategy 策略模式
在软件构建过程中,某些对象使用的算法可能多种多样,经常改变,如果将这些算法都编码到对象中,将会使对象变得异常复杂;而且有时候支持不使用的算法也是一个性能负担。
```C++
class TaxStrategy{
public:
    virtual double Calculate(const Context& context)=0;
    virtual ~TaxStrategy(){}
};


class CNTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class USTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class SalesOrder{
private:
    TaxStrategy* strategy;

public:
    SalesOrder(StrategyFactory* strategyFactory){
        this->strategy = strategyFactory->NewStrategy();
    }
    ~SalesOrder(){
        delete this->strategy;
    }

    public double CalculateTax(){
        //...
        Context context();
        
        double val = 
            strategy->Calculate(context); //多态调用
        //...
    }
    
};

```
### 模式定义
定义一系列算法,把它们一个个封装起来,并且使它们可互相替换(变化)。该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展,子类化)。
![](_v_images/20201003160954051_1338471555.png)

Strategy及其子类为组件提供了一系列可重用的算法,从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
Strategy模式提供了用条件判断语句以外的另一种选择,消除条件判断语句,就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
如果Strategy对象没有实例变量,那么各个上下文可以共享同一个Strategy对象（Singleton),从而节省对象开销。
## Observer 观察者模式
###  组件协作模式
可分类归属于 组件协作模式，组件协作”模式通过晚期绑定,来实现框架与应用程序之间的松耦合，典型的组件协作模式包括：Template Method，Strategy，Observer / Event
### 动机
在软件构建过程中,我们需要为某些对象建立一种“通知依赖关系” ——一个对象(目标对象)的状态发生改变,所有的依赖对象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密,将使软件不能很好地抵御变化。
### 模式定义
定义对象间的一种一对多(变化)的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
![](_v_images/20201007160606717_1031777405.png)

使用面向对象的抽象,Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
目标发送通知时，无需指定观察者，通知(可以携带通知信息作为参数)会自动传播。
观察者自己决定是否需要订阅通知，目标对象对此一无所知。
Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。
```C++
// 重构前：将具体的某个观察者（progressBar）放到主界面中，但无法适应变化的观察者要求，也许会有不同的进度条需求
class FileSplitter
{
	string m_filePath;
	int m_fileNumber;
	ProgressBar* m_progressBar;

public:
	FileSplitter(const string& filePath, int fileNumber, ProgressBar* progressBar) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber),
		m_progressBar(progressBar){
	}

	void split(){
		//1.读取大文件
		
		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			m_progressBar->setValue(progressValue);
		}
	}
};


class MainForm : public Form
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;

public:
	void Button1_Click(){
		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		FileSplitter splitter(filePath, number, progressBar);

		splitter.split();
	}
};

// 重构后：使用MainForm继承自IProgress（C++推荐的继承自接口），
class IProgress{
public:
	virtual void DoProgress(float value) = 0;
	virtual ~IProgress(){}
};


class FileSplitter
{
	string m_filePath;
	int m_fileNumber;
	vector<IProgress*>  m_iprogressList; // 抽象通知机制，支持多个观察者

public:
	FileSplitter(const string& filePath, int fileNumber) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber){
	}

	void split(){
		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...

			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			onProgress(progressValue);//发送通知
		}
	}


	void addIProgress(IProgress* iprogress){
		m_iprogressList.push_back(iprogress);
	}

	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}


protected:
	virtual void onProgress(float value){
		vector<IProgress*>::iterator itor=m_iprogressList.begin();
		while (itor != m_iprogressList.end() )
			(*itor)->DoProgress(value); //更新进度条
			itor++;
		}
	}
};


class ConsoleNotifier : public IProgress {
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};


class MainForm : public Form, public IProgress
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;

	ProgressBar* progressBar;

public:
	void Button1_Click(){
		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		ConsoleNotifier cn;

		FileSplitter splitter(filePath, number);

		splitter.addIProgress(this); // Windows风格的MainForm订阅通知
		splitter.addIProgress(&cn); // Console订阅通知

		splitter.split();

		splitter.removeIProgress(this);
	}

	virtual void DoProgress(float value){
		progressBar->setValue(value);
	}
};
```
## Decorator 装饰模式
### “单一职责”模式
在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

不同于前面的设计模式，属于“单一职责”模式，其典型模式包括：Decorator，Bridge
### 动机
在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多(扩展功能的增多)，各种子类的组合(扩展功能的组合)会导致更多子类的膨胀。

如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低?
### 模式定义
动态(组合)地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码 & 减少子类个数)，即组合优于继承。
### 要点
通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。

Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。——既继承某一个类，又使用该类作为组合类。

Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。
```C++
//***********************************************
// 原操作，以Stream为基类，扩展文件流，内存流等子类。
// 这时，还要加入缓存，加密等新特性，原操作做法是分别拓展出更多的子类，
// 但是这样的组合类数量会成指数增加，代码冗余度高。
// 总类的个数：1+n+(Cm~1+Cm~2+...) = n+2^n;
//***********************************************
//业务操作
class Stream{
public：
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;

    virtual ~Stream(){}
};

//主体类
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
    }
    virtual void Seek(int position){
        //定位文件流
    }
    virtual void Write(char data){
        //写文件流
    }
};

class NetworkStream :public Stream{
public:
    virtual char Read(int number);
    virtual void Seek(int position);
    virtual void Write(char data);
};

class MemoryStream :public Stream{
public:
    virtual char Read(int number);
    virtual void Seek(int position);
    virtual void Write(char data);
};

//扩展操作
class CryptoFileStream :public FileStream{
public:
    virtual char Read(int number){
        //额外的加密操作...
        FileStream::Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        FileStream::Seek(position);//定位文件流
    }
    virtual void Write(byte data){
        //额外的加密操作...
        FileStream::Write(data);//写文件流
    }
};

class CryptoNetworkStream : :public NetworkStream{
public:
    virtual char Read(int number){
        //额外的加密操作...
        NetworkStream::Read(number);//读网络流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        NetworkStream::Seek(position);//定位网络流
    }
    virtual void Write(byte data){
        //额外的加密操作...
        NetworkStream::Write(data);//写网络流
    }
};

class CryptoMemoryStream : public MemoryStream{
    //...
};

class BufferedFileStream : public FileStream{
    //...
};

class BufferedNetworkStream : public NetworkStream{
    //...
};

class BufferedMemoryStream : public MemoryStream{
    //...
}

// 组合多种特征的类
class CryptoBufferedFileStream :public FileStream{
    //...
};


void Process(){
    //编译时装配
    CryptoFileStream *fs1 = new CryptoFileStream();

    BufferedFileStream *fs2 = new BufferedFileStream();

    CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream();
}

//***********************************************
// Decorator设计模式，主体类和扩展的文件流等不变。
// 对于缓存等新特性，只设计对应特性的类而不指定对应具体哪个类，
// 由于该类需要有Stream基类的那些接口，所以需要继承自Stream，
// 同时由于想要运行时绑定具体流类型，所以还得传入一个具体流成员变量，所以还得有一个基类Stream成员变量
// 在这里，中间实现了一个Decorator类以方便后面继承。
// 总类的个数：1+n+1+m;
//***********************************************


//业务操作
class Stream{
public：
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;

    virtual ~Stream(){}
};

//主体类
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
    }
    virtual void Seek(int position){
        //定位文件流
    }
    virtual void Write(char data){
        //写文件流
    }
};

class NetworkStream :public Stream{
public:
    virtual char Read(int number);
    virtual void Seek(int position);
    virtual void Write(char data);
};

class MemoryStream :public Stream{
public:
    virtual char Read(int number);
    virtual void Seek(int position);
    virtual void Write(char data);
};

//扩展操作，中间增加 DecoratorStream 类
DecoratorStream: public Stream{
protected:
    Stream* stream;//...

    DecoratorStream(Stream * stm):stream(stm) {}
};

class CryptoStream: public DecoratorStream {
public:
    CryptoStream(Stream* stm):DecoratorStream(stm) {}

    virtual char Read(int number){
        //额外的加密操作...
        stream->Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        stream->Seek(position);//定位文件流
    }
    virtual void Write(byte data){
        //额外的加密操作...
        stream->Write(data);//写文件流
    }
};



class BufferedStream : public DecoratorStream{
public:
    BufferedStream(Stream* stm):DecoratorStream(stm) {}
    //...
};


void Process(){
    //运行时装配
    FileStream* s1=new FileStream();
    CryptoStream* s2=new CryptoStream(s1);
    BufferedStream* s3=new BufferedStream(s1);

    BufferedStream* s4=new BufferedStream(s2);
}
```
组织格式演化：
![](_v_images/20201010173738564_1192032141.png =473x) ==> ![](_v_images/20201010173654053_824867230.png =500x)